<?
  include_once ("../../../lib/inc.php");
  global $timesteps;

  // try to find the work

  $work = openopusdownparse ("work/detail/{$_REQUEST["wid"]}.json");
  
  if (!$work)
  {
    // if work doesn't exist, return an error

    $apireturn["status"] = Array ("success"=>"false", "error"=>"Work not found");
  }
  else
  {
    // work exists

    $work["recording"]["spotify_albumid"] = $_REQUEST["aid"];

    $apireturn["work"] = arraydelete ($work, ["fullname", "namesearch", "alternatetitles"])["work"];
    $apireturn["work"]["composer"] = $work["composer"];
    
    $apireturn["recording"] = Array
      (
         "spotify_albumid"=>$_REQUEST["aid"],
         "spotify_tracks"=>Array (),
         "performers"=>Array (),
         "tracks"=>Array (),
      );

    // fetching data from spotify

    $apireturn["recording"]["length"] = 0;
    $apireturn["status"] = Array ("success"=>"true", "source"=>"ext");

    $spot = fetchspotify ($work, "tracks");

    if (sizeof ($spot["items"]) <= 0)
    {
      preg_match_all (CATALOGUE_REGEX, $work[0]["title"], $matches);
      $work[0]["title"] = str_replace ($matches[0][0], "", $work[0]["title"]);
      $spot = fetchspotify ($work, "tracks");
    }

    // guessing the performers

    $perfs = openopusdownparse ("dyn/performer/list/", ["names"=>json_encode (end($spot["items"])["performers"])]);
    $rldb = $perfs["performers"]["digest"];

    // adding extradata to spotify results

    $spot = extradata ($spot, Array ("wid"=>$_REQUEST["wid"], "aid"=>$_REQUEST["aid"], "set"=>$_REQUEST["set"]));

    if ($spot["extras"]["observation"]) $apireturn["work"]["subtitle"] = $spot["extras"]["observation"];

    $spotres = $spot["items"];
    $apireturn["status"]["stats"] = $spot["stats"];

    foreach ($spotres as $tart)
    {
      $trinsert[] = Array
      (
        "cd" => $tart["cd"],
        "position" => $tart["position"],
        "length" => $tart["length"],
        "title" => $tart["title"],
        "spotify_trackid" => $tart["spotify_trackid"]
      );

      $apireturn["recording"]["tracks"][] = end ($trinsert);
      $apireturn["recording"]["length"] += end($trinsert)["length"];
    }

    $apireturn["recording"]["verified"] = $spot["extras"]["verified"] ? "true" : "false";
    $apireturn["recording"]["cover"] = $spot["extras"]["cover"];
    $apireturn["recording"]["set"] = $_REQUEST["set"];
    $apireturn["recording"]["year"] = explode ("-", $spot["extras"]["year"])[0];
    $apireturn["recording"]["markets"] = $spot["extras"]["markets"];
    $apireturn["recording"]["label"] = $spot["extras"]["label"];
    $apireturn["recording"]["performers"] = (end($spotres)["extraperformers"]) ? end($spotres)["extraperformers"]: allperformers (end($spotres)["performers"], $rldb, $apireturn["work"]["composer"]["complete_name"]);
  }

  // setting auxiliary trackset

  if (isset ($apireturn["recording"]["tracks"]) && $apireturn["recording"]["spotify_albumid"])
  {
    foreach ($apireturn["recording"]["tracks"] as $trid => $track)
    {
      $apireturn["recording"]["spotify_tracks"][] = "spotify:track:". $apireturn["recording"]["tracks"][$trid]["spotify_trackid"];
    }
  }

  echo savecache ("/recording/detail/work/{$_REQUEST["wid"]}/album/{$_REQUEST["aid"]}/{$_REQUEST["set"]}.json", apireturn ($apireturn));